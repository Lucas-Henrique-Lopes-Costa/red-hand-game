# INFORMAÇÕES GERAIS

Nome do jogo: LumberJack

Integrantes do grupo:
- Lucas Henrique Lopes Costa
- Pedro Gonçalves Costa Melo
- Guilherme Resende Mendes da Silva
- Alexsander Davi Naves Olegario

# GAMEPLAY

Número de classes de atores com ação:
    21, incluindo algumas classes de mundo.

Número de classes de mundo:
    10 Classes

Qual classe que não é ator nem mundo?
    Arvore, Jogador, Musicas e HistoricoPontuacao.

Número de arquivos de áudio usados: 
    8 arquivos de sons, incluindo musicas e efeitos sonoros.

Permite várias partidas no próprio gameplay? 
    Sim

Tem tela inicial?
    Sim, com opção para ir para a tela de tutorial.

Tem tela de histórico de pontuação?
    Sim, e pode ser acessada a partir de qualque tela de derrota.

# REQUISITOS DE OO

Atende aos requisitos de OO da primeira entrega?
    Legibilidade de código, organização e uso de comentários: Cremos que a indentação do código, nome das variáveis e funçoes ficaram fáceis de serem entendidos. Tambem cremos que a quantidade de comentários ficou na medida certa para explicar funções mais complexas.
    O codigo deve compilar: nosso cádigo compila perffeitamente, sem erros de execução.
    Implementação: a implementação usa o greenfoot.
    Funções Lambda: Não fizemos o uso de nenhuma função lambda, assim como foi exigido.
Tem alta coesão?
    Nos esforçamos para que as classes e métodos façam o necessário para seu funcionamento e nada mais, tentando delegar as atividades necessárias para as devidas classes e métodos.
Tem baixo acoplamento?
    É um dos pontos menos desenvolvidos de nosso código. Cremos que havia a ´´possibilidade de diminuir e muito o acoplamento entre nossas classes. Durante o desenvolvimento, não demos a importância necessária para o baixo acoplamento do código.
Usa design baseado em responsabilidade?
    Sim, como foi dito na parte da coesão, tentamos implementar o código de forma que cada classe correspondesse com sua responsabilidade e somente com ela.
Tem acoplamento implícito?
    Não identificamos nenhum componente que pode ser classificado com acoplamento implícito.
Tem replicação de código?
    Possivelmente existem pequenos trechos que replicam códigos e funções, mas em um geral, cremos que a replicação de código foi tratada de forma correta.
Tem duas superclasses com subclasses com implementação útil?
    Sim. Uma delas é a classe Barra, que tem como subclasse a classe Timer. A outra é a Superclasse Projetil, que engloba todos os três objetos que são parte dos ataques do dragão.

# COMENTÁRIOS (OPCIONAIS)

Algum comentário sobre o tema do trabalho?
    Lucas:
        Achei interessante ser um jogo, porque foge do normal de criar coisas que a gente aplica mais para gente aprender apenas, não ver tanto uso na prática. Pode até ser que tenha uso na prática como o projeto que fizemos em ialg, mas não é tão prático como o jogo, que a gente pode compartilhar e deixa o desenvolvimento divertido além de trazer muitos conhecimentos sobre programação orientada a objeto.
    Pedro:
        O tema do trabalho foi cativante e me inspirou a me dedicar mais, pois foi algo que fiquei imerso, tentando otimizar o jogo e adicionar novas funcionalidades. Em geral, acho que foi uma ótima escolha  de tema para o trabalho, e que dificilmente teria aprendido mais sobre java e orientação a Objetos com outro tema ou outra abordagem.

Algum comentário sobre o Greenfoot?
    Lucas:
        Não gostei da IDE, mas entendo a praticidade que ela traz para gente que está aprendendo, a entender as classes e herança, além de possuir a sua biblioteca bem documentada. De modo geral é muito boa, mas ainda sim prefiro outras engines, que já trazem muitos recursos que funcionam melhor. Uma vantagem do Greenfoot, é que fazemos tudo na mão, então o conhecimento adquirido é bem maior, porque temos que resolver os erros da nossa forma
    Pedro:
        Acho que o Greenfoot é a escolha certa para a diciplina, visto sua abordagem de simplificar muito as coisas. Dito isso, confesso fiquei um pouco decepcionado quanto ao nível de simplificação, e diversas vezes me peguei com vontade de estar utilizando algo mais aplicável no dia a dia e mais eficiênte. Não tenho uma solução para esse problema, visto que a barreira que usar uma engine "de verdade" poderia criar talvez fosse alta demais e desmotivasse a exxecução do trabalho. Acho que o certo a se fazer é realmente manter o Greenfoot, já que ao chegar em IPOO, tive que aprender não so a programação orientada a objetos, mas também a linguagem java. Portando, creio adicionar mais uma ferramenta complexa à lista não seria uma boa escolha. 
